.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_optimize_autoscheduler_tutorials_tune_network_cuda.py>`     to download the full example code
    .. rst-class:: sphx-glr-example-title

    .. _sphx_glr_optimize_autoscheduler_tutorials_tune_network_cuda.py:


Auto-scheduling a Neural Network for NVIDIA GPU
===============================================
**Author**: `Lianmin Zheng <https://github.com/merrymercy>`_

Auto-tuning for specific devices and workloads is critical for getting the
best performance. This is a tutorial on how to tune a whole neural
network for NVIDIA GPU with the auto-scheduler.

To auto-tune a neural network, we partition the network into small subgraphs and 
tune them independently. Each subgraph is treated as one search task.
A task scheduler slices the time and dynamically allocates time resources to
these tasks. The task scheduler predicts the impact of each task on the end-to-end
execution time and prioritizes the one that can reduce the execution time the most.

For each subgraph, we use the compute declaration in :code:`tvm/python/topi` to
get the computational DAG in the tensor expression form.
We then use the auto-scheduler to construct a search space of this DAG and search
for good schedules (low-level optimizations).

Different from the template-based :ref:`autotvm <tutorials-autotvm-sec>` which relies on
manual templates to define the search space, the auto-scheduler does not require any
schedule templates. In other words, the auto-scheduler only uses the compute declarations
in :code:`tvm/python/topi` and does not use existing schedule templates.

Note that this tutorial will not run on Windows or recent versions of macOS. To
get it to run, you will need to wrap the body of this tutorial in a :code:`if
__name__ == "__main__":` block.


.. code-block:: default


    import numpy as np

    import tvm
    from tvm import relay, auto_scheduler
    import tvm.relay.testing
    from tvm.contrib import graph_runtime








Define a Network
----------------
First, we need to define the network with relay frontend API.
We can load some pre-defined network from :code:`tvm.relay.testing`.
We can also load models from MXNet, ONNX, PyTorch, and TensorFlow
(see :ref:`front end tutorials<tutorial-frontend>`).

For convolutional neural networks, although auto-scheduler can work correctly
with any layout, we found the best performance is typically achieved with NHWC layout.
We also implemented more optimizations for NHWC layout with the auto-scheduler.
So it is recommended to convert your models to NHWC layout to use the auto-scheduler.
You can use :ref:`ConvertLayout <convert-layout-usage>` pass to do the layout conversion in TVM.


.. code-block:: default



    def get_network(name, batch_size, layout="NHWC", dtype="float32"):
        """Get the symbol definition and random weight of a network"""

        # auto-scheduler prefers NHWC layout
        if layout == "NHWC":
            image_shape = (224, 224, 3)
        elif layout == "NCHW":
            image_shape = (3, 224, 224)
        else:
            raise ValueError("Invalid layout: " + layout)

        input_shape = (batch_size,) + image_shape
        output_shape = (batch_size, 1000)

        if name.startswith("resnet-"):
            n_layer = int(name.split("-")[1])
            mod, params = relay.testing.resnet.get_workload(
                num_layers=n_layer,
                batch_size=batch_size,
                layout=layout,
                dtype=dtype,
                image_shape=image_shape,
            )
        elif name.startswith("resnet3d-"):
            n_layer = int(name.split("-")[1])
            mod, params = relay.testing.resnet.get_workload(
                num_layers=n_layer,
                batch_size=batch_size,
                layout=layout,
                dtype=dtype,
                image_shape=image_shape,
            )
        elif name == "mobilenet":
            mod, params = relay.testing.mobilenet.get_workload(
                batch_size=batch_size, layout=layout, dtype=dtype, image_shape=image_shape
            )
        elif name == "squeezenet_v1.1":
            assert layout == "NCHW", "squeezenet_v1.1 only supports NCHW layout"
            mod, params = relay.testing.squeezenet.get_workload(
                version="1.1",
                batch_size=batch_size,
                dtype=dtype,
                image_shape=image_shape,
            )
        elif name == "inception_v3":
            input_shape = (batch_size, 3, 299, 299) if layout == "NCHW" else (batch_size, 299, 299, 3)
            mod, params = relay.testing.inception_v3.get_workload(batch_size=batch_size, dtype=dtype)
        elif name == "mxnet":
            # an example for mxnet model
            from mxnet.gluon.model_zoo.vision import get_model

            assert layout == "NCHW"

            block = get_model("resnet18_v1", pretrained=True)
            mod, params = relay.frontend.from_mxnet(block, shape={"data": input_shape}, dtype=dtype)
            net = mod["main"]
            net = relay.Function(
                net.params, relay.nn.softmax(net.body), None, net.type_params, net.attrs
            )
            mod = tvm.IRModule.from_expr(net)

        return mod, params, input_shape, output_shape


    # Define the neural network and compilation target
    network = "resnet-18"
    batch_size = 1
    layout = "NHWC"
    target = tvm.target.Target("cuda")
    dtype = "float32"
    log_file = "%s-%s-B%d-%s.json" % (network, layout, batch_size, target.kind.name)








Extract Search Tasks
--------------------
Next, we extract the search tasks and their weights from a network.
The weight of a task is the number of appearances of the task's subgraph
in the whole network.
By using the weight, we can approximate the end-to-end latency of the network
as :code:`sum(latency[t] * weight[t])`, where :code:`latency[t]` is the
latency of a task and :code:`weight[t]` is the weight of the task.
The task scheduler will just optimize this objective.


.. code-block:: default


    # Extract tasks from the network
    print("Extract tasks...")
    mod, params, input_shape, output_shape = get_network(network, batch_size, layout, dtype=dtype)
    tasks, task_weights = auto_scheduler.extract_tasks(mod["main"], params, target)

    for idx, task in enumerate(tasks):
        print("========== Task %d  (workload key: %s) ==========" % (idx, task.workload_key))
        print(task.compute_dag)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Extract tasks...
    Exception in thread Thread-1:
    Traceback (most recent call last):
      File "/usr/local/Cellar/python/3.7.7/Frameworks/Python.framework/Versions/3.7/lib/python3.7/threading.py", line 926, in _bootstrap_inner
        self.run()
      File "/usr/local/Cellar/python/3.7.7/Frameworks/Python.framework/Versions/3.7/lib/python3.7/threading.py", line 870, in run
        self._target(*self._args, **self._kwargs)
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/auto_scheduler/relay_integration.py", line 59, in call_all_topi_funcs
        opt_mod, _ = relay.optimize(mod, target, params)
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/relay/build_module.py", line 329, in optimize
        mod, params = bld_mod.optimize(mod, target, params)
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/relay/build_module.py", line 177, in optimize
        mod = self._optimize(mod, target)
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/_ffi/_ctypes/packed_func.py", line 237, in __call__
        raise get_last_ffi_error()
    tvm._ffi.base.TVMError: Traceback (most recent call last):
      [bt] (8) 9   libtvm.dylib                        0x0000000111de6518 tvm::relay::ExprFunctor<tvm::RelayExpr (tvm::RelayExpr const&)>::InitVTable()::'lambda4'(tvm::runtime::ObjectRef const&, tvm::relay::ExprFunctor<tvm::RelayExpr (tvm::RelayExpr const&)>*)::__invoke(tvm::runtime::ObjectRef const&, tvm::relay::ExprFunctor<tvm::RelayExpr (tvm::RelayExpr const&)>*) + 24
      [bt] (7) 8   libtvm.dylib                        0x0000000111d63fae tvm::relay::MixedModeMutator::VisitExpr_(tvm::relay::CallNode const*) + 14
      [bt] (6) 7   libtvm.dylib                        0x0000000111d65589 tvm::RelayExpr tvm::relay::MixedModeMutator::Rewrite<tvm::relay::CallNode>(tvm::relay::CallNode const*) + 57
      [bt] (5) 6   libtvm.dylib                        0x0000000111db5079 tvm::relay::ForwardRewriter::Rewrite_(tvm::relay::CallNode const*, tvm::RelayExpr const&) + 1689
      [bt] (4) 5   libtvm.dylib                        0x0000000111db6485 tvm::runtime::TVMRetValue tvm::runtime::PackedFunc::operator()<tvm::relay::Call const&, tvm::runtime::Array<tvm::RelayExpr, void>&, tvm::runtime::ObjectRef>(tvm::relay::Call const&, tvm::runtime::Array<tvm::RelayExpr, void>&, tvm::runtime::ObjectRef&&) const + 245
      [bt] (3) 4   libtvm.dylib                        0x0000000111d25566 void tvm::runtime::TypedPackedFunc<tvm::RelayExpr (tvm::relay::Call const&, tvm::runtime::Array<tvm::RelayExpr, void> const&, tvm::runtime::ObjectRef const&)>::AssignTypedLambda<tvm::RelayExpr (*)(tvm::relay::Call const&, tvm::runtime::Array<tvm::RelayExpr, void> const&, tvm::runtime::ObjectRef const&)>(tvm::RelayExpr (*)(tvm::relay::Call const&, tvm::runtime::Array<tvm::RelayExpr, void> const&, tvm::runtime::ObjectRef const&))::'lambda'(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const + 582
      [bt] (2) 3   libtvm.dylib                        0x0000000111d28a1b tvm::RelayExpr tvm::relay::LayoutRewriter<tvm::relay::alter_op_layout::AlterTransformMemorizer>(tvm::relay::Call const&, tvm::runtime::Array<tvm::RelayExpr, void> const&, tvm::runtime::ObjectRef const&) + 3211
      [bt] (1) 2   libtvm.dylib                        0x0000000111d2bfd0 tvm::relay::alter_op_layout::AlterTransformMemorizer::CallWithNewLayouts(tvm::relay::Call const&, std::__1::vector<tvm::RelayExpr, std::__1::allocator<tvm::RelayExpr> > const&) + 1088
      [bt] (0) 1   libtvm.dylib                        0x000000011201c7a5 std::__1::__function::__func<TVMFuncCreateFromCFunc::$_2, std::__1::allocator<TVMFuncCreateFromCFunc::$_2>, void (tvm::runtime::TVMArgs, tvm::runtime::TVMRetValue*)>::operator()(tvm::runtime::TVMArgs&&, tvm::runtime::TVMRetValue*&&) + 213
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/_ffi/_ctypes/packed_func.py", line 81, in cfun
        rv = local_pyfunc(*pyargs)
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/relay/op/nn/_nn.py", line 119, in alter_op_layout_conv2d
        return topi.nn.conv2d_alter_layout(attrs, inputs, tinfos, out_type)
      File "<decorator-gen-55>", line 2, in conv2d_alter_layout
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/target/generic_func.py", line 275, in dispatch_func
        return dispatch_dict[k](*args, **kwargs)
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/topi/cuda/conv2d_alter_op.py", line 48, in _alter_conv2d_layout
        relay.op.get("nn.conv2d"), attrs, tinfos, out_type, target
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/relay/backend/compile_engine.py", line 189, in select_implementation
        all_impls = get_valid_implementations(op, attrs, inputs, out_type, target)
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/relay/backend/compile_engine.py", line 130, in get_valid_implementations
        strategy = fstrategy(attrs, inputs, out_type, target)
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/target/generic_func.py", line 46, in __call__
        return _ffi_api.GenericFuncCallFunc(self, *args)
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/_ffi/_ctypes/packed_func.py", line 237, in __call__
        raise get_last_ffi_error()
      [bt] (5) 6   ???                                 0x000070000e3564f0 0x0 + 123145540691184
      [bt] (4) 5   _ctypes.cpython-37m-darwin.so       0x0000000104125347 ffi_call_unix64 + 79
      [bt] (3) 4   libtvm.dylib                        0x000000011201a468 TVMFuncCall + 72
      [bt] (2) 3   libtvm.dylib                        0x0000000111920142 std::__1::__function::__func<tvm::$_5, std::__1::allocator<tvm::$_5>, void (tvm::runtime::TVMArgs, tvm::runtime::TVMRetValue*)>::operator()(tvm::runtime::TVMArgs&&, tvm::runtime::TVMRetValue*&&) + 178
      [bt] (1) 2   libtvm.dylib                        0x000000011191dfd7 tvm::GenericFunc::CallPacked(tvm::runtime::TVMArgs, tvm::runtime::TVMRetValue*) const + 743
      [bt] (0) 1   libtvm.dylib                        0x000000011201c7a5 std::__1::__function::__func<TVMFuncCreateFromCFunc::$_2, std::__1::allocator<TVMFuncCreateFromCFunc::$_2>, void (tvm::runtime::TVMArgs, tvm::runtime::TVMRetValue*)>::operator()(tvm::runtime::TVMArgs&&, tvm::runtime::TVMRetValue*&&) + 213
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/_ffi/_ctypes/packed_func.py", line 81, in cfun
        rv = local_pyfunc(*pyargs)
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/relay/op/strategy/cuda.py", line 218, in conv2d_strategy_cuda
        and nvcc.have_tensorcore(tvm.gpu(0).compute_version)
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/_ffi/runtime_ctypes.py", line 237, in compute_version
        return self._GetDeviceAttr(self.device_type, self.device_id, 4)
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/_ffi/runtime_ctypes.py", line 204, in _GetDeviceAttr
        return tvm.runtime._ffi_api.GetDeviceAttr(device_type, device_id, attr_id)
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/_ffi/_ctypes/packed_func.py", line 237, in __call__
        raise get_last_ffi_error()
      [bt] (6) 7   ???                                 0x000070000e354f00 0x0 + 123145540685568
      [bt] (5) 6   _ctypes.cpython-37m-darwin.so       0x0000000104125347 ffi_call_unix64 + 79
      [bt] (4) 5   libtvm.dylib                        0x000000011201a468 TVMFuncCall + 72
      [bt] (3) 4   libtvm.dylib                        0x000000011201cc1c std::__1::__function::__func<$_4, std::__1::allocator<$_4>, void (tvm::runtime::TVMArgs, tvm::runtime::TVMRetValue*)>::operator()(tvm::runtime::TVMArgs&&, tvm::runtime::TVMRetValue*&&) + 220
      [bt] (2) 3   libtvm.dylib                        0x000000011201b993 tvm::runtime::DeviceAPIManager::GetAPI(int, bool) + 371
      [bt] (1) 2   libtvm.dylib                        0x000000011201bbbb tvm::runtime::DeviceAPIManager::GetAPI(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, bool) + 411
      [bt] (0) 1   libtvm.dylib                        0x00000001111b0d0f dmlc::LogMessageFatal::~LogMessageFatal() + 111
      File "../src/runtime/c_runtime_api.cc", line 131
    TVMError: 
    ---------------------------------------------------------------
    An internal invariant was violated during the execution of TVM.
    Please read TVM's error reporting guidelines.
    More details can be found here: https://discuss.tvm.ai/t/error-reporting/7793.
    ---------------------------------------------------------------
      Check failed: allow_missing == false: Device API gpu is not enabled.





Begin Tuning
------------
Now, we set some options for tuning and launch the search tasks

* :code:`measure_ctx` launches a different process for measurement to
  provide isolation. It can protect the master process from GPU crashes
  during measurement and avoid other runtime conflicts.
* :code:`min_repeat_ms` defines the minimum duration of one "repeat" in every measurement.
  This can warmup the GPU, which is necessary to get accurate measurement results.
  Typically, we recommend a value >= 300 ms.
* :code:`num_measure_trials` is the number of measurement trials we can use during the tuning.
  You can set it to a small number (e.g., 200) for a fast demonstrative run.
  In practice, we recommend setting it around :code:`900 * len(tasks)`,
  which is typically enough for the search to converge.
  For example, there are 24 tasks in resnet-18, so we can set it as 20000.
  You can adjust this parameter according to your time budget.
* In addition, we use :code:`RecordToFile` to dump measurement records into a log file,
  The measurement records can be used to query the history best, resume the search,
  and do more analyses later.
* see :any:`auto_scheduler.TuningOptions`,
  :any:`auto_scheduler.LocalRPCMeasureContext` for more parameters.



.. code-block:: default



    def run_tuning():
        print("Begin tuning...")
        measure_ctx = auto_scheduler.LocalRPCMeasureContext(repeat=1, min_repeat_ms=300, timeout=10)

        tuner = auto_scheduler.TaskScheduler(tasks, task_weights)
        tune_option = auto_scheduler.TuningOptions(
            num_measure_trials=200,  # change this to 20000 to achieve the best performance
            runner=measure_ctx.runner,
            measure_callbacks=[auto_scheduler.RecordToFile(log_file)],
        )

        tuner.tune(tune_option)


    # We do not run the tuning in our webpage server since it takes too long.
    # Uncomment the following line to run it by yourself.

    # run_tuning()









.. note:: Explain the printed information during tuning

  During the tuning, a lot of information will be printed on the console.
  They are used for debugging purposes. The most important info is the output
  of the task scheduler. The following table is a sample output.

  .. code-block:: c

    ----------------------------------------------------------------------
    ------------------------------  [ Task Scheduler ]
    ----------------------------------------------------------------------
    |  ID  | Latency (ms) | Speed (GFLOPS) | Trials |
    -------------------------------------------------
    |    0 |        0.005 |           0.88 |     64 |
    |    1 |        0.010 |          99.10 |     64 |
    |    2 |        0.006 |           0.00 |     64 |
    |    3 |        0.145 |         979.78 |    384 |
    |    4 |        0.130 |        1097.02 |    384 |
    |    5 |        0.143 |         992.69 |    384 |
    |    6 |        0.076 |        1526.86 |    192 |
    |    7 |        0.115 |         999.44 |    320 |
    |    8 |        0.079 |        1449.39 |    320 |
    |    9 |        0.122 |         938.73 |    384 |
    |   10 |        0.063 |        1832.98 |    192 |
    |   11 |        0.072 |        1763.62 |    256 |
    |   12 |        0.062 |        2036.40 |    192 |
    |   13 |        0.068 |        1874.44 |    192 |
    |   14 |        0.049 |        2346.50 |    128 |
    |   15 |        0.076 |        1694.31 |    256 |
    |   16 |        0.067 |        1933.30 |    448 |
    |   17 |        0.076 |        1680.90 |    256 |
    |   18 |        0.022 |          98.43 |     64 |
    |   19 |        0.076 |        3112.55 |    192 |
    |   20 |        0.013 |        2026.44 |     64 |
    |   21 |        0.011 |        1136.69 |     64 |
    |   22 |        0.013 |         992.47 |     64 |
    |   23 |        0.020 |         627.56 |     64 |
    -------------------------------------------------
    Estimated total latency: 1.587 ms  Trials: 4992  Used time : 13296 s  Next ID: 3

  This table lists the latency and (estimated) speed of all tasks.
  It also lists the allocation of measurement trials for all tasks.
  The last line prints the total weighted latency of these tasks,
  which can be a rough estimation of the end-to-end execution time
  of the network.
  The last line also prints the total number of measurement trials,
  total time spent on auto-tuning and the id of the next task to tune.

  There will also be some "dmlc::Error"s and CUDA errors, because the
  auto-scheduler will try some invalid schedules.
  You can safely ignore them if the tuning can continue, because these
  errors are isolated from the main process.


.. note:: Terminate the tuning earlier

  You can terminate the tuning earlier by forcibly killing this process.
  As long as you get at least one valid schedule for each task in the log file,
  you should be able to do the compilation (the secion below).


Compile and Evaluate
--------------------
After auto-tuning, we can compile the network with the best schedules we found.
All measurement records are dumped into the log file during auto-tuning,
so we can read the log file and load the best schedules.


.. code-block:: default


    # Compile with the history best
    print("Compile...")
    with auto_scheduler.ApplyHistoryBest(log_file):
        with tvm.transform.PassContext(opt_level=3, config={"relay.backend.use_auto_scheduler": True}):
            lib = relay.build(mod, target=target, params=params)

    # Create graph runtime
    ctx = tvm.context(str(target), 0)
    module = graph_runtime.GraphModule(lib["default"](ctx))
    data_tvm = tvm.nd.array((np.random.uniform(size=input_shape)).astype(dtype))
    module.set_input("data", data_tvm)

    # Evaluate
    print("Evaluate inference time cost...")
    ftimer = module.module.time_evaluator("run", ctx, repeat=3, min_repeat_ms=500)
    prof_res = np.array(ftimer().results) * 1e3  # convert to millisecond
    print("Mean inference time (std dev): %.2f ms (%.2f ms)" % (np.mean(prof_res), np.std(prof_res)))




.. rst-class:: sphx-glr-script-out


.. code-block:: pytb

    Traceback (most recent call last):
      File "/Users/andrew/ws/tvm2/docs/optimize/autoscheduler/tutorials-src/tune_network_cuda.py", line 281, in <module>
        lib = relay.build(mod, target=target, params=params)
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/relay/build_module.py", line 275, in build
        graph_json, mod, params = bld_mod.build(mod, target, target_host, params)
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/relay/build_module.py", line 138, in build
        self._build(mod, target, target_host)
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/_ffi/_ctypes/packed_func.py", line 237, in __call__
        raise get_last_ffi_error()
    tvm._ffi.base.TVMError: Traceback (most recent call last):
      [bt] (8) 9   libtvm.dylib                        0x0000000111de6518 tvm::relay::ExprFunctor<tvm::RelayExpr (tvm::RelayExpr const&)>::InitVTable()::'lambda4'(tvm::runtime::ObjectRef const&, tvm::relay::ExprFunctor<tvm::RelayExpr (tvm::RelayExpr const&)>*)::__invoke(tvm::runtime::ObjectRef const&, tvm::relay::ExprFunctor<tvm::RelayExpr (tvm::RelayExpr const&)>*) + 24
      [bt] (7) 8   libtvm.dylib                        0x0000000111d63fae tvm::relay::MixedModeMutator::VisitExpr_(tvm::relay::CallNode const*) + 14
      [bt] (6) 7   libtvm.dylib                        0x0000000111d65589 tvm::RelayExpr tvm::relay::MixedModeMutator::Rewrite<tvm::relay::CallNode>(tvm::relay::CallNode const*) + 57
      [bt] (5) 6   libtvm.dylib                        0x0000000111db5079 tvm::relay::ForwardRewriter::Rewrite_(tvm::relay::CallNode const*, tvm::RelayExpr const&) + 1689
      [bt] (4) 5   libtvm.dylib                        0x0000000111db6485 tvm::runtime::TVMRetValue tvm::runtime::PackedFunc::operator()<tvm::relay::Call const&, tvm::runtime::Array<tvm::RelayExpr, void>&, tvm::runtime::ObjectRef>(tvm::relay::Call const&, tvm::runtime::Array<tvm::RelayExpr, void>&, tvm::runtime::ObjectRef&&) const + 245
      [bt] (3) 4   libtvm.dylib                        0x0000000111d25566 void tvm::runtime::TypedPackedFunc<tvm::RelayExpr (tvm::relay::Call const&, tvm::runtime::Array<tvm::RelayExpr, void> const&, tvm::runtime::ObjectRef const&)>::AssignTypedLambda<tvm::RelayExpr (*)(tvm::relay::Call const&, tvm::runtime::Array<tvm::RelayExpr, void> const&, tvm::runtime::ObjectRef const&)>(tvm::RelayExpr (*)(tvm::relay::Call const&, tvm::runtime::Array<tvm::RelayExpr, void> const&, tvm::runtime::ObjectRef const&))::'lambda'(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const + 582
      [bt] (2) 3   libtvm.dylib                        0x0000000111d28a1b tvm::RelayExpr tvm::relay::LayoutRewriter<tvm::relay::alter_op_layout::AlterTransformMemorizer>(tvm::relay::Call const&, tvm::runtime::Array<tvm::RelayExpr, void> const&, tvm::runtime::ObjectRef const&) + 3211
      [bt] (1) 2   libtvm.dylib                        0x0000000111d2bfd0 tvm::relay::alter_op_layout::AlterTransformMemorizer::CallWithNewLayouts(tvm::relay::Call const&, std::__1::vector<tvm::RelayExpr, std::__1::allocator<tvm::RelayExpr> > const&) + 1088
      [bt] (0) 1   libtvm.dylib                        0x000000011201c7a5 std::__1::__function::__func<TVMFuncCreateFromCFunc::$_2, std::__1::allocator<TVMFuncCreateFromCFunc::$_2>, void (tvm::runtime::TVMArgs, tvm::runtime::TVMRetValue*)>::operator()(tvm::runtime::TVMArgs&&, tvm::runtime::TVMRetValue*&&) + 213
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/_ffi/_ctypes/packed_func.py", line 81, in cfun
        rv = local_pyfunc(*pyargs)
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/relay/op/nn/_nn.py", line 119, in alter_op_layout_conv2d
        return topi.nn.conv2d_alter_layout(attrs, inputs, tinfos, out_type)
      File "<decorator-gen-55>", line 2, in conv2d_alter_layout
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/target/generic_func.py", line 275, in dispatch_func
        return dispatch_dict[k](*args, **kwargs)
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/topi/cuda/conv2d_alter_op.py", line 48, in _alter_conv2d_layout
        relay.op.get("nn.conv2d"), attrs, tinfos, out_type, target
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/relay/backend/compile_engine.py", line 189, in select_implementation
        all_impls = get_valid_implementations(op, attrs, inputs, out_type, target)
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/relay/backend/compile_engine.py", line 130, in get_valid_implementations
        strategy = fstrategy(attrs, inputs, out_type, target)
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/target/generic_func.py", line 46, in __call__
        return _ffi_api.GenericFuncCallFunc(self, *args)
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/_ffi/_ctypes/packed_func.py", line 237, in __call__
        raise get_last_ffi_error()
      [bt] (5) 6   ???                                 0x00007ffeed664760 0x0 + 140732881323872
      [bt] (4) 5   _ctypes.cpython-37m-darwin.so       0x0000000104125347 ffi_call_unix64 + 79
      [bt] (3) 4   libtvm.dylib                        0x000000011201a468 TVMFuncCall + 72
      [bt] (2) 3   libtvm.dylib                        0x0000000111920142 std::__1::__function::__func<tvm::$_5, std::__1::allocator<tvm::$_5>, void (tvm::runtime::TVMArgs, tvm::runtime::TVMRetValue*)>::operator()(tvm::runtime::TVMArgs&&, tvm::runtime::TVMRetValue*&&) + 178
      [bt] (1) 2   libtvm.dylib                        0x000000011191dfd7 tvm::GenericFunc::CallPacked(tvm::runtime::TVMArgs, tvm::runtime::TVMRetValue*) const + 743
      [bt] (0) 1   libtvm.dylib                        0x000000011201c7a5 std::__1::__function::__func<TVMFuncCreateFromCFunc::$_2, std::__1::allocator<TVMFuncCreateFromCFunc::$_2>, void (tvm::runtime::TVMArgs, tvm::runtime::TVMRetValue*)>::operator()(tvm::runtime::TVMArgs&&, tvm::runtime::TVMRetValue*&&) + 213
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/_ffi/_ctypes/packed_func.py", line 81, in cfun
        rv = local_pyfunc(*pyargs)
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/relay/op/strategy/cuda.py", line 218, in conv2d_strategy_cuda
        and nvcc.have_tensorcore(tvm.gpu(0).compute_version)
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/_ffi/runtime_ctypes.py", line 237, in compute_version
        return self._GetDeviceAttr(self.device_type, self.device_id, 4)
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/_ffi/runtime_ctypes.py", line 204, in _GetDeviceAttr
        return tvm.runtime._ffi_api.GetDeviceAttr(device_type, device_id, attr_id)
      File "/Users/andrew/ws/tvm2/docs/../python/tvm/_ffi/_ctypes/packed_func.py", line 237, in __call__
        raise get_last_ffi_error()
      [bt] (6) 7   ???                                 0x00007ffeed663170 0x0 + 140732881318256
      [bt] (5) 6   _ctypes.cpython-37m-darwin.so       0x0000000104125347 ffi_call_unix64 + 79
      [bt] (4) 5   libtvm.dylib                        0x000000011201a468 TVMFuncCall + 72
      [bt] (3) 4   libtvm.dylib                        0x000000011201cc1c std::__1::__function::__func<$_4, std::__1::allocator<$_4>, void (tvm::runtime::TVMArgs, tvm::runtime::TVMRetValue*)>::operator()(tvm::runtime::TVMArgs&&, tvm::runtime::TVMRetValue*&&) + 220
      [bt] (2) 3   libtvm.dylib                        0x000000011201b993 tvm::runtime::DeviceAPIManager::GetAPI(int, bool) + 371
      [bt] (1) 2   libtvm.dylib                        0x000000011201bbbb tvm::runtime::DeviceAPIManager::GetAPI(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, bool) + 411
      [bt] (0) 1   libtvm.dylib                        0x00000001111b0d0f dmlc::LogMessageFatal::~LogMessageFatal() + 111
      File "../src/runtime/c_runtime_api.cc", line 131
    TVMError: 
    ---------------------------------------------------------------
    An internal invariant was violated during the execution of TVM.
    Please read TVM's error reporting guidelines.
    More details can be found here: https://discuss.tvm.ai/t/error-reporting/7793.
    ---------------------------------------------------------------
      Check failed: allow_missing == false: Device API gpu is not enabled.




Other Tips
----------
1. During the tuning, the auto-scheduler needs to compile many programs and
   extract feature from them. This part is CPU-intensive,
   so a high-performance CPU with many cores is recommended for faster search.
2. You can use :code:`python3 -m tvm.auto_scheduler.measure_record --mode distill --i log.json`
   to distill the large log file and only save the best useful records.
3. You can resume a search from the previous log file. You just need to
   add a new argument :code:`load_log_file` when creating the task scheduler
   in function :code:`run_tuning`. Say,
   :code:`tuner = auto_scheduler.TaskScheduler(tasks, task_weights, load_log_file=log_file)`
4. If you have multiple target GPUs, you can use all of them for measurements to
   parallelize the measurements. Check this :ref:`section <tutorials-autotvm-rpc-tracker>`
   to learn how to use the RPC Tracker and RPC Server.
   To use the RPC Tracker in auto-scheduler, replace the runner in :code:`TuningOptions`
   with :any:`auto_scheduler.RPCRunner`.


.. _sphx_glr_download_optimize_autoscheduler_tutorials_tune_network_cuda.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: tune_network_cuda.py <tune_network_cuda.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: tune_network_cuda.ipynb <tune_network_cuda.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
